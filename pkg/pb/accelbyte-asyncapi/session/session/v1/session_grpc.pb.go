// Copyright (c) 2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

// source: Session/AsyncAPI/session.yaml (0.1.0)

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.9
// source: accelbyte-asyncapi/session/session/v1/session.proto

package session

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SessionEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.SessionEventService/OnMessage"
)

// SessionEventServiceClient is the client API for SessionEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a message to the Session channel. (session Event)
type SessionEventServiceClient interface {
	OnMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionEventServiceClient(cc grpc.ClientConnInterface) SessionEventServiceClient {
	return &sessionEventServiceClient{cc}
}

func (c *sessionEventServiceClient) OnMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionEventServiceServer is the server API for SessionEventService service.
// All implementations should embed UnimplementedSessionEventServiceServer
// for forward compatibility.
//
// Publishes a message to the Session channel. (session Event)
type SessionEventServiceServer interface {
	OnMessage(context.Context, *Event) (*emptypb.Empty, error)
}

// UnimplementedSessionEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionEventServiceServer struct{}

func (UnimplementedSessionEventServiceServer) OnMessage(context.Context, *Event) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedSessionEventServiceServer) testEmbeddedByValue() {}

// UnsafeSessionEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionEventServiceServer will
// result in compilation errors.
type UnsafeSessionEventServiceServer interface {
	mustEmbedUnimplementedSessionEventServiceServer()
}

func RegisterSessionEventServiceServer(s grpc.ServiceRegistrar, srv SessionEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedSessionEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionEventService_ServiceDesc, srv)
}

func _SessionEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionEventServiceServer).OnMessage(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionEventService_ServiceDesc is the grpc.ServiceDesc for SessionEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.SessionEventService",
	HandlerType: (*SessionEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _SessionEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	SessionNotificationSessionNotificationService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.SessionNotificationSessionNotificationService/OnMessage"
)

// SessionNotificationSessionNotificationServiceClient is the client API for SessionNotificationSessionNotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a message to the Session Notification channel. (sessionNotification SessionNotification)
type SessionNotificationSessionNotificationServiceClient interface {
	OnMessage(ctx context.Context, in *SessionNotification, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionNotificationSessionNotificationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionNotificationSessionNotificationServiceClient(cc grpc.ClientConnInterface) SessionNotificationSessionNotificationServiceClient {
	return &sessionNotificationSessionNotificationServiceClient{cc}
}

func (c *sessionNotificationSessionNotificationServiceClient) OnMessage(ctx context.Context, in *SessionNotification, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionNotificationSessionNotificationService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionNotificationSessionNotificationServiceServer is the server API for SessionNotificationSessionNotificationService service.
// All implementations should embed UnimplementedSessionNotificationSessionNotificationServiceServer
// for forward compatibility.
//
// Publishes a message to the Session Notification channel. (sessionNotification SessionNotification)
type SessionNotificationSessionNotificationServiceServer interface {
	OnMessage(context.Context, *SessionNotification) (*emptypb.Empty, error)
}

// UnimplementedSessionNotificationSessionNotificationServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionNotificationSessionNotificationServiceServer struct{}

func (UnimplementedSessionNotificationSessionNotificationServiceServer) OnMessage(context.Context, *SessionNotification) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedSessionNotificationSessionNotificationServiceServer) testEmbeddedByValue() {}

// UnsafeSessionNotificationSessionNotificationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionNotificationSessionNotificationServiceServer will
// result in compilation errors.
type UnsafeSessionNotificationSessionNotificationServiceServer interface {
	mustEmbedUnimplementedSessionNotificationSessionNotificationServiceServer()
}

func RegisterSessionNotificationSessionNotificationServiceServer(s grpc.ServiceRegistrar, srv SessionNotificationSessionNotificationServiceServer) {
	// If the following call pancis, it indicates UnimplementedSessionNotificationSessionNotificationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionNotificationSessionNotificationService_ServiceDesc, srv)
}

func _SessionNotificationSessionNotificationService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionNotification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionNotificationSessionNotificationServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionNotificationSessionNotificationService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionNotificationSessionNotificationServiceServer).OnMessage(ctx, req.(*SessionNotification))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionNotificationSessionNotificationService_ServiceDesc is the grpc.ServiceDesc for SessionNotificationSessionNotificationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionNotificationSessionNotificationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.SessionNotificationSessionNotificationService",
	HandlerType: (*SessionNotificationSessionNotificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _SessionNotificationSessionNotificationService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	SessionEventOnSessionEndedService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.SessionEventOnSessionEndedService/OnMessage"
)

// SessionEventOnSessionEndedServiceClient is the client API for SessionEventOnSessionEndedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a message to the Session Event channel. (sessionEvent OnSessionEnded)
type SessionEventOnSessionEndedServiceClient interface {
	OnMessage(ctx context.Context, in *OnSessionEnded, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionEventOnSessionEndedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionEventOnSessionEndedServiceClient(cc grpc.ClientConnInterface) SessionEventOnSessionEndedServiceClient {
	return &sessionEventOnSessionEndedServiceClient{cc}
}

func (c *sessionEventOnSessionEndedServiceClient) OnMessage(ctx context.Context, in *OnSessionEnded, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionEventOnSessionEndedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionEventOnSessionEndedServiceServer is the server API for SessionEventOnSessionEndedService service.
// All implementations should embed UnimplementedSessionEventOnSessionEndedServiceServer
// for forward compatibility.
//
// Publishes a message to the Session Event channel. (sessionEvent OnSessionEnded)
type SessionEventOnSessionEndedServiceServer interface {
	OnMessage(context.Context, *OnSessionEnded) (*emptypb.Empty, error)
}

// UnimplementedSessionEventOnSessionEndedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionEventOnSessionEndedServiceServer struct{}

func (UnimplementedSessionEventOnSessionEndedServiceServer) OnMessage(context.Context, *OnSessionEnded) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedSessionEventOnSessionEndedServiceServer) testEmbeddedByValue() {}

// UnsafeSessionEventOnSessionEndedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionEventOnSessionEndedServiceServer will
// result in compilation errors.
type UnsafeSessionEventOnSessionEndedServiceServer interface {
	mustEmbedUnimplementedSessionEventOnSessionEndedServiceServer()
}

func RegisterSessionEventOnSessionEndedServiceServer(s grpc.ServiceRegistrar, srv SessionEventOnSessionEndedServiceServer) {
	// If the following call pancis, it indicates UnimplementedSessionEventOnSessionEndedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionEventOnSessionEndedService_ServiceDesc, srv)
}

func _SessionEventOnSessionEndedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSessionEnded)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionEventOnSessionEndedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionEventOnSessionEndedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionEventOnSessionEndedServiceServer).OnMessage(ctx, req.(*OnSessionEnded))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionEventOnSessionEndedService_ServiceDesc is the grpc.ServiceDesc for SessionEventOnSessionEndedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionEventOnSessionEndedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.SessionEventOnSessionEndedService",
	HandlerType: (*SessionEventOnSessionEndedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _SessionEventOnSessionEndedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionEndedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionEndedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionEndedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionEndedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionEndedEvent)
type Mpv2SessionHistoryGameSessionEndedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionEndedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionEndedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionEndedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionEndedEventServiceClient {
	return &mpv2SessionHistoryGameSessionEndedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionEndedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionEndedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionEndedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionEndedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionEndedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionEndedEvent)
type Mpv2SessionHistoryGameSessionEndedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionEndedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer) OnMessage(context.Context, *GameSessionEndedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryGameSessionEndedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionEndedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionEndedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionEndedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionEndedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionEndedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionEndedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionEndedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionEndedEventServiceServer).OnMessage(ctx, req.(*GameSessionEndedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionEndedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionEndedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionEndedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionEndedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionEndedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionInvitedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionInvitedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionInvitedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionInvitedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionInvitedEvent)
type Mpv2SessionHistoryGameSessionInvitedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionInvitedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionInvitedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionInvitedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionInvitedEventServiceClient {
	return &mpv2SessionHistoryGameSessionInvitedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionInvitedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionInvitedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionInvitedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionInvitedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionInvitedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionInvitedEvent)
type Mpv2SessionHistoryGameSessionInvitedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionInvitedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer) OnMessage(context.Context, *GameSessionInvitedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryGameSessionInvitedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionInvitedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionInvitedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionInvitedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionInvitedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionInvitedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionInvitedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionInvitedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionInvitedEventServiceServer).OnMessage(ctx, req.(*GameSessionInvitedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionInvitedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionInvitedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionInvitedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionInvitedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionInvitedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionJoinedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionJoinedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionJoinedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionJoinedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionJoinedEvent)
type Mpv2SessionHistoryGameSessionJoinedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionJoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionJoinedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionJoinedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionJoinedEventServiceClient {
	return &mpv2SessionHistoryGameSessionJoinedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionJoinedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionJoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionJoinedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionJoinedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionJoinedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionJoinedEvent)
type Mpv2SessionHistoryGameSessionJoinedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionJoinedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer) OnMessage(context.Context, *GameSessionJoinedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryGameSessionJoinedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionJoinedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionJoinedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionJoinedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionJoinedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionJoinedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionJoinedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionJoinedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionJoinedEventServiceServer).OnMessage(ctx, req.(*GameSessionJoinedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionJoinedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionJoinedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionJoinedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionJoinedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionJoinedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionMembersChangedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionMembersChangedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionMembersChangedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionMembersChangedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionMembersChangedEvent)
type Mpv2SessionHistoryGameSessionMembersChangedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionMembersChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionMembersChangedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionMembersChangedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionMembersChangedEventServiceClient {
	return &mpv2SessionHistoryGameSessionMembersChangedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionMembersChangedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionMembersChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionMembersChangedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionMembersChangedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionMembersChangedEvent)
type Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionMembersChangedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer) OnMessage(context.Context, *GameSessionMembersChangedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryGameSessionMembersChangedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionMembersChangedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionMembersChangedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionMembersChangedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionMembersChangedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer).OnMessage(ctx, req.(*GameSessionMembersChangedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionMembersChangedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionMembersChangedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionMembersChangedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionMembersChangedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionKickedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionKickedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionKickedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionKickedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionKickedEvent)
type Mpv2SessionHistoryGameSessionKickedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionKickedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionKickedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionKickedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionKickedEventServiceClient {
	return &mpv2SessionHistoryGameSessionKickedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionKickedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionKickedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionKickedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionKickedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionKickedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionKickedEvent)
type Mpv2SessionHistoryGameSessionKickedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionKickedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer) OnMessage(context.Context, *GameSessionKickedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryGameSessionKickedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionKickedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionKickedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionKickedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionKickedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionKickedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionKickedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionKickedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionKickedEventServiceServer).OnMessage(ctx, req.(*GameSessionKickedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionKickedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionKickedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionKickedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionKickedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionKickedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCreatedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionCreatedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionCreatedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionCreatedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionCreatedEvent)
type Mpv2SessionHistoryGameSessionCreatedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionCreatedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionCreatedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionCreatedEventServiceClient {
	return &mpv2SessionHistoryGameSessionCreatedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionCreatedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionCreatedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionCreatedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionCreatedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionCreatedEvent)
type Mpv2SessionHistoryGameSessionCreatedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionCreatedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer) OnMessage(context.Context, *GameSessionCreatedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryGameSessionCreatedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionCreatedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionCreatedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionCreatedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionCreatedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionCreatedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionCreatedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionCreatedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionCreatedEventServiceServer).OnMessage(ctx, req.(*GameSessionCreatedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionCreatedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionCreatedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionCreatedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCreatedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionCreatedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionUpdatedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionUpdatedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionUpdatedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionUpdatedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionUpdatedEvent)
type Mpv2SessionHistoryGameSessionUpdatedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionUpdatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionUpdatedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionUpdatedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionUpdatedEventServiceClient {
	return &mpv2SessionHistoryGameSessionUpdatedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionUpdatedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionUpdatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionUpdatedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionUpdatedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionUpdatedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionUpdatedEvent)
type Mpv2SessionHistoryGameSessionUpdatedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionUpdatedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer) OnMessage(context.Context, *GameSessionUpdatedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryGameSessionUpdatedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionUpdatedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionUpdatedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionUpdatedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionUpdatedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionUpdatedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionUpdatedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionUpdatedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionUpdatedEventServiceServer).OnMessage(ctx, req.(*GameSessionUpdatedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionUpdatedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionUpdatedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionUpdatedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionUpdatedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionUpdatedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionRejectedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionRejectedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionRejectedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionRejectedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionRejectedEvent)
type Mpv2SessionHistoryGameSessionRejectedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionRejectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionRejectedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionRejectedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionRejectedEventServiceClient {
	return &mpv2SessionHistoryGameSessionRejectedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionRejectedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionRejectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionRejectedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionRejectedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionRejectedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionRejectedEvent)
type Mpv2SessionHistoryGameSessionRejectedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionRejectedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer) OnMessage(context.Context, *GameSessionRejectedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryGameSessionRejectedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionRejectedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionRejectedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionRejectedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionRejectedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionRejectedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionRejectedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionRejectedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionRejectedEventServiceServer).OnMessage(ctx, req.(*GameSessionRejectedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionRejectedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionRejectedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionRejectedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionRejectedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionRejectedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionDSStatusChangedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionDSStatusChangedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionDSStatusChangedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionDSStatusChangedEvent)
type Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionDSStatusChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient {
	return &mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionDSStatusChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionDSStatusChangedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionDSStatusChangedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionDSStatusChangedEvent)
type Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionDSStatusChangedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer) OnMessage(context.Context, *GameSessionDSStatusChangedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionDSStatusChangedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionDSStatusChangedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer).OnMessage(ctx, req.(*GameSessionDSStatusChangedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionDSStatusChangedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionDSStatusChangedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionDSStatusChangedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionDSStatusChangedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCodeChangedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionCodeChangedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionCodeChangedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionCodeChangedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionCodeChangedEvent)
type Mpv2SessionHistoryGameSessionCodeChangedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionCodeChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionCodeChangedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionCodeChangedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionCodeChangedEventServiceClient {
	return &mpv2SessionHistoryGameSessionCodeChangedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionCodeChangedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionCodeChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionCodeChangedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionCodeChangedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionCodeChangedEvent)
type Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionCodeChangedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer) OnMessage(context.Context, *GameSessionCodeChangedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryGameSessionCodeChangedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionCodeChangedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionCodeChangedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionCodeChangedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionCodeChangedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer).OnMessage(ctx, req.(*GameSessionCodeChangedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionCodeChangedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionCodeChangedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionCodeChangedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCodeChangedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCodeRevokedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionCodeRevokedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionCodeRevokedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionCodeRevokedEvent)
type Mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionCodeRevokedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionCodeRevokedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient {
	return &mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionCodeRevokedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionCodeRevokedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionCodeRevokedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionCodeRevokedEvent)
type Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionCodeRevokedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer) OnMessage(context.Context, *GameSessionCodeRevokedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionCodeRevokedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionCodeRevokedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer).OnMessage(ctx, req.(*GameSessionCodeRevokedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionCodeRevokedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionCodeRevokedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionCodeRevokedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCodeRevokedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyCreatedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyCreatedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyCreatedEventServiceClient is the client API for Mpv2SessionHistoryPartyCreatedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyCreatedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyCreatedEvent)
type Mpv2SessionHistoryPartyCreatedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyCreatedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyCreatedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyCreatedEventServiceClient {
	return &mpv2SessionHistoryPartyCreatedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyCreatedEventServiceClient) OnMessage(ctx context.Context, in *PartyCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyCreatedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyCreatedEventServiceServer is the server API for Mpv2SessionHistoryPartyCreatedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyCreatedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyCreatedEvent)
type Mpv2SessionHistoryPartyCreatedEventServiceServer interface {
	OnMessage(context.Context, *PartyCreatedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer) OnMessage(context.Context, *PartyCreatedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyCreatedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyCreatedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyCreatedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyCreatedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyCreatedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyCreatedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyCreatedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyCreatedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyCreatedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyCreatedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyCreatedEventServiceServer).OnMessage(ctx, req.(*PartyCreatedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyCreatedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyCreatedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyCreatedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyCreatedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyCreatedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyCreatedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyUpdatedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyUpdatedEventServiceClient is the client API for Mpv2SessionHistoryPartyUpdatedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyUpdatedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyUpdatedEvent)
type Mpv2SessionHistoryPartyUpdatedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyUpdatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyUpdatedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyUpdatedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyUpdatedEventServiceClient {
	return &mpv2SessionHistoryPartyUpdatedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyUpdatedEventServiceClient) OnMessage(ctx context.Context, in *PartyUpdatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyUpdatedEventServiceServer is the server API for Mpv2SessionHistoryPartyUpdatedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyUpdatedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyUpdatedEvent)
type Mpv2SessionHistoryPartyUpdatedEventServiceServer interface {
	OnMessage(context.Context, *PartyUpdatedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer) OnMessage(context.Context, *PartyUpdatedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyUpdatedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyUpdatedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyUpdatedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyUpdatedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyUpdatedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyUpdatedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyUpdatedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyUpdatedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyUpdatedEventServiceServer).OnMessage(ctx, req.(*PartyUpdatedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyUpdatedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyUpdatedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyUpdatedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyUpdatedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyUpdatedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyKickedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyKickedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyKickedEventServiceClient is the client API for Mpv2SessionHistoryPartyKickedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyKickedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyKickedEvent)
type Mpv2SessionHistoryPartyKickedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyKickedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyKickedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyKickedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyKickedEventServiceClient {
	return &mpv2SessionHistoryPartyKickedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyKickedEventServiceClient) OnMessage(ctx context.Context, in *PartyKickedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyKickedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyKickedEventServiceServer is the server API for Mpv2SessionHistoryPartyKickedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyKickedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyKickedEvent)
type Mpv2SessionHistoryPartyKickedEventServiceServer interface {
	OnMessage(context.Context, *PartyKickedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer) OnMessage(context.Context, *PartyKickedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyKickedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyKickedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyKickedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyKickedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyKickedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyKickedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyKickedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyKickedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyKickedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyKickedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyKickedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyKickedEventServiceServer).OnMessage(ctx, req.(*PartyKickedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyKickedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyKickedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyKickedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyKickedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyKickedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyKickedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyLeaveEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyLeaveEventService/OnMessage"
)

// Mpv2SessionHistoryPartyLeaveEventServiceClient is the client API for Mpv2SessionHistoryPartyLeaveEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyLeaveEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyLeaveEvent)
type Mpv2SessionHistoryPartyLeaveEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyLeaveEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyLeaveEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyLeaveEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyLeaveEventServiceClient {
	return &mpv2SessionHistoryPartyLeaveEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyLeaveEventServiceClient) OnMessage(ctx context.Context, in *PartyLeaveEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyLeaveEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyLeaveEventServiceServer is the server API for Mpv2SessionHistoryPartyLeaveEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer
// for forward compatibility.
//
// Publishes a PartyLeaveEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyLeaveEvent)
type Mpv2SessionHistoryPartyLeaveEventServiceServer interface {
	OnMessage(context.Context, *PartyLeaveEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer) OnMessage(context.Context, *PartyLeaveEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyLeaveEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyLeaveEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyLeaveEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyLeaveEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyLeaveEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyLeaveEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyLeaveEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyLeaveEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyLeaveEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyLeaveEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyLeaveEventServiceServer).OnMessage(ctx, req.(*PartyLeaveEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyLeaveEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyLeaveEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyLeaveEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyLeaveEventService",
	HandlerType: (*Mpv2SessionHistoryPartyLeaveEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyLeaveEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyInvitedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyInvitedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyInvitedEventServiceClient is the client API for Mpv2SessionHistoryPartyInvitedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyInvitedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyInvitedEvent)
type Mpv2SessionHistoryPartyInvitedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyInvitedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyInvitedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyInvitedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyInvitedEventServiceClient {
	return &mpv2SessionHistoryPartyInvitedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyInvitedEventServiceClient) OnMessage(ctx context.Context, in *PartyInvitedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyInvitedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyInvitedEventServiceServer is the server API for Mpv2SessionHistoryPartyInvitedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyInvitedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyInvitedEvent)
type Mpv2SessionHistoryPartyInvitedEventServiceServer interface {
	OnMessage(context.Context, *PartyInvitedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer) OnMessage(context.Context, *PartyInvitedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyInvitedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyInvitedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyInvitedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyInvitedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyInvitedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyInvitedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyInvitedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyInvitedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyInvitedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyInvitedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyInvitedEventServiceServer).OnMessage(ctx, req.(*PartyInvitedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyInvitedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyInvitedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyInvitedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyInvitedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyInvitedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyInvitedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyRejectedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyRejectedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyRejectedEventServiceClient is the client API for Mpv2SessionHistoryPartyRejectedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyRejectedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyRejectedEvent)
type Mpv2SessionHistoryPartyRejectedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyRejectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyRejectedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyRejectedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyRejectedEventServiceClient {
	return &mpv2SessionHistoryPartyRejectedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyRejectedEventServiceClient) OnMessage(ctx context.Context, in *PartyRejectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyRejectedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyRejectedEventServiceServer is the server API for Mpv2SessionHistoryPartyRejectedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyRejectedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyRejectedEvent)
type Mpv2SessionHistoryPartyRejectedEventServiceServer interface {
	OnMessage(context.Context, *PartyRejectedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer) OnMessage(context.Context, *PartyRejectedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyRejectedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyRejectedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyRejectedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyRejectedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyRejectedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyRejectedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyRejectedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyRejectedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyRejectedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyRejectedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyRejectedEventServiceServer).OnMessage(ctx, req.(*PartyRejectedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyRejectedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyRejectedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyRejectedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyRejectedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyRejectedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyRejectedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyJoinedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyJoinedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyJoinedEventServiceClient is the client API for Mpv2SessionHistoryPartyJoinedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyJoinedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyJoinedEvent)
type Mpv2SessionHistoryPartyJoinedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyJoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyJoinedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyJoinedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyJoinedEventServiceClient {
	return &mpv2SessionHistoryPartyJoinedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyJoinedEventServiceClient) OnMessage(ctx context.Context, in *PartyJoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyJoinedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyJoinedEventServiceServer is the server API for Mpv2SessionHistoryPartyJoinedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyJoinedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyJoinedEvent)
type Mpv2SessionHistoryPartyJoinedEventServiceServer interface {
	OnMessage(context.Context, *PartyJoinedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer) OnMessage(context.Context, *PartyJoinedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyJoinedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyJoinedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyJoinedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyJoinedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyJoinedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyJoinedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyJoinedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyJoinedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyJoinedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyJoinedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyJoinedEventServiceServer).OnMessage(ctx, req.(*PartyJoinedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyJoinedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyJoinedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyJoinedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyJoinedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyJoinedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyJoinedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyMembersChangedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyMembersChangedEventServiceClient is the client API for Mpv2SessionHistoryPartyMembersChangedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyMembersChangedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyMembersChangedEvent)
type Mpv2SessionHistoryPartyMembersChangedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyMembersChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyMembersChangedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyMembersChangedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyMembersChangedEventServiceClient {
	return &mpv2SessionHistoryPartyMembersChangedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyMembersChangedEventServiceClient) OnMessage(ctx context.Context, in *PartyMembersChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyMembersChangedEventServiceServer is the server API for Mpv2SessionHistoryPartyMembersChangedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyMembersChangedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyMembersChangedEvent)
type Mpv2SessionHistoryPartyMembersChangedEventServiceServer interface {
	OnMessage(context.Context, *PartyMembersChangedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer) OnMessage(context.Context, *PartyMembersChangedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyMembersChangedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyMembersChangedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyMembersChangedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyMembersChangedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyMembersChangedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyMembersChangedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyMembersChangedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyMembersChangedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyMembersChangedEventServiceServer).OnMessage(ctx, req.(*PartyMembersChangedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyMembersChangedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyMembersChangedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyMembersChangedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyMembersChangedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyMembersChangedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricTotalActiveSessionEventService/OnMessage"
)

// Mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient is the client API for Mpv2SessionHistoryMetricTotalActiveSessionEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a MetricTotalActiveSessionEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricTotalActiveSessionEvent)
type Mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricTotalActiveSessionEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricTotalActiveSessionEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient {
	return &mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient) OnMessage(ctx context.Context, in *MetricTotalActiveSessionEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer is the server API for Mpv2SessionHistoryMetricTotalActiveSessionEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer
// for forward compatibility.
//
// Publishes a MetricTotalActiveSessionEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricTotalActiveSessionEvent)
type Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer interface {
	OnMessage(context.Context, *MetricTotalActiveSessionEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer) OnMessage(context.Context, *MetricTotalActiveSessionEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryMetricTotalActiveSessionEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricTotalActiveSessionEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer).OnMessage(ctx, req.(*MetricTotalActiveSessionEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricTotalActiveSessionEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricTotalActiveSessionEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricTotalActiveSessionEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricTotalActiveSessionEventService",
	HandlerType: (*Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService/OnMessage"
)

// Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient is the client API for Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a MetricAcquiringDsWaitTimeEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricAcquiringDsWaitTimeEvent)
type Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricAcquiringDsWaitTimeEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient {
	return &mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient) OnMessage(ctx context.Context, in *MetricAcquiringDsWaitTimeEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer is the server API for Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer
// for forward compatibility.
//
// Publishes a MetricAcquiringDsWaitTimeEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricAcquiringDsWaitTimeEvent)
type Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer interface {
	OnMessage(context.Context, *MetricAcquiringDsWaitTimeEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer) OnMessage(context.Context, *MetricAcquiringDsWaitTimeEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricAcquiringDsWaitTimeEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer).OnMessage(ctx, req.(*MetricAcquiringDsWaitTimeEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService",
	HandlerType: (*Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricAcquiringDsEventService/OnMessage"
)

// Mpv2SessionHistoryMetricAcquiringDsEventServiceClient is the client API for Mpv2SessionHistoryMetricAcquiringDsEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a MetricAcquiringDsEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricAcquiringDsEvent)
type Mpv2SessionHistoryMetricAcquiringDsEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricAcquiringDsEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricAcquiringDsEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricAcquiringDsEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricAcquiringDsEventServiceClient {
	return &mpv2SessionHistoryMetricAcquiringDsEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricAcquiringDsEventServiceClient) OnMessage(ctx context.Context, in *MetricAcquiringDsEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricAcquiringDsEventServiceServer is the server API for Mpv2SessionHistoryMetricAcquiringDsEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer
// for forward compatibility.
//
// Publishes a MetricAcquiringDsEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricAcquiringDsEvent)
type Mpv2SessionHistoryMetricAcquiringDsEventServiceServer interface {
	OnMessage(context.Context, *MetricAcquiringDsEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer) OnMessage(context.Context, *MetricAcquiringDsEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryMetricAcquiringDsEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricAcquiringDsEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricAcquiringDsEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricAcquiringDsEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricAcquiringDsEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryMetricAcquiringDsEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricAcquiringDsEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricAcquiringDsEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricAcquiringDsEventServiceServer).OnMessage(ctx, req.(*MetricAcquiringDsEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricAcquiringDsEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricAcquiringDsEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricAcquiringDsEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricAcquiringDsEventService",
	HandlerType: (*Mpv2SessionHistoryMetricAcquiringDsEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricMatchLengthDurationEventService/OnMessage"
)

// Mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient is the client API for Mpv2SessionHistoryMetricMatchLengthDurationEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a MetricMatchLengthDurationEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricMatchLengthDurationEvent)
type Mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricMatchLengthDurationEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricMatchLengthDurationEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient {
	return &mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient) OnMessage(ctx context.Context, in *MetricMatchLengthDurationEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer is the server API for Mpv2SessionHistoryMetricMatchLengthDurationEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer
// for forward compatibility.
//
// Publishes a MetricMatchLengthDurationEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricMatchLengthDurationEvent)
type Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer interface {
	OnMessage(context.Context, *MetricMatchLengthDurationEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer) OnMessage(context.Context, *MetricMatchLengthDurationEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryMetricMatchLengthDurationEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricMatchLengthDurationEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer).OnMessage(ctx, req.(*MetricMatchLengthDurationEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricMatchLengthDurationEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricMatchLengthDurationEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricMatchLengthDurationEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricMatchLengthDurationEventService",
	HandlerType: (*Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionBackfillUpdateEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionBackfillUpdateEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceClient is the client API for Mpv2SessionHistoryGameSessionBackfillUpdateEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameSessionBackfillUpdateEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionBackfillUpdateEvent)
type Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionBackfillUpdateEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionBackfillUpdateEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionBackfillUpdateEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceClient {
	return &mpv2SessionHistoryGameSessionBackfillUpdateEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionBackfillUpdateEventServiceClient) OnMessage(ctx context.Context, in *GameSessionBackfillUpdateEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionBackfillUpdateEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer is the server API for Mpv2SessionHistoryGameSessionBackfillUpdateEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer
// for forward compatibility.
//
// Publishes a GameSessionBackfillUpdateEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory GameSessionBackfillUpdateEvent)
type Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer interface {
	OnMessage(context.Context, *GameSessionBackfillUpdateEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer) OnMessage(context.Context, *GameSessionBackfillUpdateEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryGameSessionBackfillUpdateEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionBackfillUpdateEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionBackfillUpdateEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionBackfillUpdateEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer).OnMessage(ctx, req.(*GameSessionBackfillUpdateEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionBackfillUpdateEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionBackfillUpdateEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionBackfillUpdateEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionBackfillUpdateEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionBackfillUpdateEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionBackfillUpdateEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMatchHistoryEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMatchHistoryEventService/OnMessage"
)

// Mpv2SessionHistoryMatchHistoryEventServiceClient is the client API for Mpv2SessionHistoryMatchHistoryEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a MatchHistoryEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MatchHistoryEvent)
type Mpv2SessionHistoryMatchHistoryEventServiceClient interface {
	OnMessage(ctx context.Context, in *MatchHistoryEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMatchHistoryEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMatchHistoryEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMatchHistoryEventServiceClient {
	return &mpv2SessionHistoryMatchHistoryEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMatchHistoryEventServiceClient) OnMessage(ctx context.Context, in *MatchHistoryEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMatchHistoryEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMatchHistoryEventServiceServer is the server API for Mpv2SessionHistoryMatchHistoryEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryMatchHistoryEventServiceServer
// for forward compatibility.
//
// Publishes a MatchHistoryEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MatchHistoryEvent)
type Mpv2SessionHistoryMatchHistoryEventServiceServer interface {
	OnMessage(context.Context, *MatchHistoryEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryMatchHistoryEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryMatchHistoryEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryMatchHistoryEventServiceServer) OnMessage(context.Context, *MatchHistoryEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMatchHistoryEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryMatchHistoryEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMatchHistoryEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMatchHistoryEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMatchHistoryEventServiceServer()
}

func RegisterMpv2SessionHistoryMatchHistoryEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMatchHistoryEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryMatchHistoryEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryMatchHistoryEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMatchHistoryEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchHistoryEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMatchHistoryEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMatchHistoryEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMatchHistoryEventServiceServer).OnMessage(ctx, req.(*MatchHistoryEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMatchHistoryEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMatchHistoryEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMatchHistoryEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMatchHistoryEventService",
	HandlerType: (*Mpv2SessionHistoryMatchHistoryEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMatchHistoryEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService/OnMessage"
)

// Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceClient is the client API for Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a MetricCreatedMatchmakingTicketEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricCreatedMatchmakingTicketEvent)
type Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricCreatedMatchmakingTicketEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceClient {
	return &mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceClient) OnMessage(ctx context.Context, in *MetricCreatedMatchmakingTicketEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer is the server API for Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer
// for forward compatibility.
//
// Publishes a MetricCreatedMatchmakingTicketEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricCreatedMatchmakingTicketEvent)
type Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer interface {
	OnMessage(context.Context, *MetricCreatedMatchmakingTicketEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer) OnMessage(context.Context, *MetricCreatedMatchmakingTicketEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricCreatedMatchmakingTicketEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer).OnMessage(ctx, req.(*MetricCreatedMatchmakingTicketEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService",
	HandlerType: (*Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricCreatedMatchmakingTicketEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricMatchMatchmakingEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricMatchMatchmakingEventService/OnMessage"
)

// Mpv2SessionHistoryMetricMatchMatchmakingEventServiceClient is the client API for Mpv2SessionHistoryMetricMatchMatchmakingEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a MetricMatchMatchmakingEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricMatchMatchmakingEvent)
type Mpv2SessionHistoryMetricMatchMatchmakingEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricMatchMatchmakingEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricMatchMatchmakingEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricMatchMatchmakingEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricMatchMatchmakingEventServiceClient {
	return &mpv2SessionHistoryMetricMatchMatchmakingEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricMatchMatchmakingEventServiceClient) OnMessage(ctx context.Context, in *MetricMatchMatchmakingEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricMatchMatchmakingEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricMatchMatchmakingEventServiceServer is the server API for Mpv2SessionHistoryMetricMatchMatchmakingEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer
// for forward compatibility.
//
// Publishes a MetricMatchMatchmakingEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricMatchMatchmakingEvent)
type Mpv2SessionHistoryMetricMatchMatchmakingEventServiceServer interface {
	OnMessage(context.Context, *MetricMatchMatchmakingEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer) OnMessage(context.Context, *MetricMatchMatchmakingEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricMatchMatchmakingEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricMatchMatchmakingEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryMetricMatchMatchmakingEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryMetricMatchMatchmakingEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricMatchMatchmakingEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricMatchMatchmakingEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricMatchMatchmakingEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricMatchMatchmakingEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricMatchMatchmakingEventServiceServer).OnMessage(ctx, req.(*MetricMatchMatchmakingEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricMatchMatchmakingEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricMatchMatchmakingEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricMatchMatchmakingEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricMatchMatchmakingEventService",
	HandlerType: (*Mpv2SessionHistoryMetricMatchMatchmakingEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricMatchMatchmakingEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService/OnMessage"
)

// Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceClient is the client API for Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a MetricMatchMatchmakingTicketEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricMatchMatchmakingTicketEvent)
type Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricMatchMatchmakingTicketEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceClient {
	return &mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceClient) OnMessage(ctx context.Context, in *MetricMatchMatchmakingTicketEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer is the server API for Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer
// for forward compatibility.
//
// Publishes a MetricMatchMatchmakingTicketEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory MetricMatchMatchmakingTicketEvent)
type Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer interface {
	OnMessage(context.Context, *MetricMatchMatchmakingTicketEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer) OnMessage(context.Context, *MetricMatchMatchmakingTicketEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer) testEmbeddedByValue() {
}

// UnsafeMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricMatchMatchmakingTicketEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer).OnMessage(ctx, req.(*MetricMatchMatchmakingTicketEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService",
	HandlerType: (*Mpv2SessionHistoryMetricMatchMatchmakingTicketEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricMatchMatchmakingTicketEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyDeletedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyDeletedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyDeletedEventServiceClient is the client API for Mpv2SessionHistoryPartyDeletedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyDeletedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyDeletedEvent)
type Mpv2SessionHistoryPartyDeletedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyDeletedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyDeletedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyDeletedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyDeletedEventServiceClient {
	return &mpv2SessionHistoryPartyDeletedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyDeletedEventServiceClient) OnMessage(ctx context.Context, in *PartyDeletedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyDeletedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyDeletedEventServiceServer is the server API for Mpv2SessionHistoryPartyDeletedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyDeletedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyDeletedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyDeletedEvent)
type Mpv2SessionHistoryPartyDeletedEventServiceServer interface {
	OnMessage(context.Context, *PartyDeletedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyDeletedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyDeletedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyDeletedEventServiceServer) OnMessage(context.Context, *PartyDeletedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyDeletedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyDeletedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyDeletedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyDeletedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyDeletedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyDeletedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyDeletedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyDeletedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyDeletedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyDeletedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyDeletedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyDeletedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyDeletedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyDeletedEventServiceServer).OnMessage(ctx, req.(*PartyDeletedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyDeletedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyDeletedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyDeletedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyDeletedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyDeletedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyDeletedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyDisconnectedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyDisconnectedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyDisconnectedEventServiceClient is the client API for Mpv2SessionHistoryPartyDisconnectedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyDisconnectedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyDisconnectedEvent)
type Mpv2SessionHistoryPartyDisconnectedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyDisconnectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyDisconnectedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyDisconnectedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyDisconnectedEventServiceClient {
	return &mpv2SessionHistoryPartyDisconnectedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyDisconnectedEventServiceClient) OnMessage(ctx context.Context, in *PartyDisconnectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyDisconnectedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyDisconnectedEventServiceServer is the server API for Mpv2SessionHistoryPartyDisconnectedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyDisconnectedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyDisconnectedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyDisconnectedEvent)
type Mpv2SessionHistoryPartyDisconnectedEventServiceServer interface {
	OnMessage(context.Context, *PartyDisconnectedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyDisconnectedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyDisconnectedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyDisconnectedEventServiceServer) OnMessage(context.Context, *PartyDisconnectedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyDisconnectedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyDisconnectedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyDisconnectedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyDisconnectedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyDisconnectedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyDisconnectedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyDisconnectedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyDisconnectedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyDisconnectedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyDisconnectedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyDisconnectedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyDisconnectedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyDisconnectedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyDisconnectedEventServiceServer).OnMessage(ctx, req.(*PartyDisconnectedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyDisconnectedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyDisconnectedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyDisconnectedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyDisconnectedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyDisconnectedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyDisconnectedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyInviteCancelledService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyInviteCancelledService/OnMessage"
)

// Mpv2SessionHistoryPartyInviteCancelledServiceClient is the client API for Mpv2SessionHistoryPartyInviteCancelledService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyInviteCancelled to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyInviteCancelled)
type Mpv2SessionHistoryPartyInviteCancelledServiceClient interface {
	OnMessage(ctx context.Context, in *PartyInviteCancelled, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyInviteCancelledServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyInviteCancelledServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyInviteCancelledServiceClient {
	return &mpv2SessionHistoryPartyInviteCancelledServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyInviteCancelledServiceClient) OnMessage(ctx context.Context, in *PartyInviteCancelled, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyInviteCancelledService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyInviteCancelledServiceServer is the server API for Mpv2SessionHistoryPartyInviteCancelledService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyInviteCancelledServiceServer
// for forward compatibility.
//
// Publishes a PartyInviteCancelled to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyInviteCancelled)
type Mpv2SessionHistoryPartyInviteCancelledServiceServer interface {
	OnMessage(context.Context, *PartyInviteCancelled) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyInviteCancelledServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyInviteCancelledServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyInviteCancelledServiceServer) OnMessage(context.Context, *PartyInviteCancelled) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyInviteCancelledServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyInviteCancelledServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyInviteCancelledServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyInviteCancelledServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyInviteCancelledServiceServer()
}

func RegisterMpv2SessionHistoryPartyInviteCancelledServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyInviteCancelledServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyInviteCancelledServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyInviteCancelledService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyInviteCancelledService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyInviteCancelled)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyInviteCancelledServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyInviteCancelledService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyInviteCancelledServiceServer).OnMessage(ctx, req.(*PartyInviteCancelled))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyInviteCancelledService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyInviteCancelledService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyInviteCancelledService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyInviteCancelledService",
	HandlerType: (*Mpv2SessionHistoryPartyInviteCancelledServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyInviteCancelledService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyLeaderChangedService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyLeaderChangedService/OnMessage"
)

// Mpv2SessionHistoryPartyLeaderChangedServiceClient is the client API for Mpv2SessionHistoryPartyLeaderChangedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyLeaderChanged to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyLeaderChanged)
type Mpv2SessionHistoryPartyLeaderChangedServiceClient interface {
	OnMessage(ctx context.Context, in *PartyLeaderChanged, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyLeaderChangedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyLeaderChangedServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyLeaderChangedServiceClient {
	return &mpv2SessionHistoryPartyLeaderChangedServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyLeaderChangedServiceClient) OnMessage(ctx context.Context, in *PartyLeaderChanged, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyLeaderChangedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyLeaderChangedServiceServer is the server API for Mpv2SessionHistoryPartyLeaderChangedService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyLeaderChangedServiceServer
// for forward compatibility.
//
// Publishes a PartyLeaderChanged to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyLeaderChanged)
type Mpv2SessionHistoryPartyLeaderChangedServiceServer interface {
	OnMessage(context.Context, *PartyLeaderChanged) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyLeaderChangedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyLeaderChangedServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyLeaderChangedServiceServer) OnMessage(context.Context, *PartyLeaderChanged) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyLeaderChangedServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyLeaderChangedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyLeaderChangedServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyLeaderChangedServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyLeaderChangedServiceServer()
}

func RegisterMpv2SessionHistoryPartyLeaderChangedServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyLeaderChangedServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyLeaderChangedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyLeaderChangedService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyLeaderChangedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyLeaderChanged)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyLeaderChangedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyLeaderChangedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyLeaderChangedServiceServer).OnMessage(ctx, req.(*PartyLeaderChanged))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyLeaderChangedService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyLeaderChangedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyLeaderChangedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyLeaderChangedService",
	HandlerType: (*Mpv2SessionHistoryPartyLeaderChangedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyLeaderChangedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyLeftEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyLeftEventService/OnMessage"
)

// Mpv2SessionHistoryPartyLeftEventServiceClient is the client API for Mpv2SessionHistoryPartyLeftEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyLeftEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyLeftEvent)
type Mpv2SessionHistoryPartyLeftEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyLeftEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyLeftEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyLeftEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyLeftEventServiceClient {
	return &mpv2SessionHistoryPartyLeftEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyLeftEventServiceClient) OnMessage(ctx context.Context, in *PartyLeftEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyLeftEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyLeftEventServiceServer is the server API for Mpv2SessionHistoryPartyLeftEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyLeftEventServiceServer
// for forward compatibility.
//
// Publishes a PartyLeftEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyLeftEvent)
type Mpv2SessionHistoryPartyLeftEventServiceServer interface {
	OnMessage(context.Context, *PartyLeftEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyLeftEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyLeftEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyLeftEventServiceServer) OnMessage(context.Context, *PartyLeftEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyLeftEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyLeftEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyLeftEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyLeftEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyLeftEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyLeftEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyLeftEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyLeftEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyLeftEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyLeftEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyLeftEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyLeftEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyLeftEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyLeftEventServiceServer).OnMessage(ctx, req.(*PartyLeftEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyLeftEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyLeftEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyLeftEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyLeftEventService",
	HandlerType: (*Mpv2SessionHistoryPartyLeftEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyLeftEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyRejoinedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyRejoinedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyRejoinedEventServiceClient is the client API for Mpv2SessionHistoryPartyRejoinedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a PartyRejoinedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyRejoinedEvent)
type Mpv2SessionHistoryPartyRejoinedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyRejoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyRejoinedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyRejoinedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyRejoinedEventServiceClient {
	return &mpv2SessionHistoryPartyRejoinedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyRejoinedEventServiceClient) OnMessage(ctx context.Context, in *PartyRejoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyRejoinedEventService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyRejoinedEventServiceServer is the server API for Mpv2SessionHistoryPartyRejoinedEventService service.
// All implementations should embed UnimplementedMpv2SessionHistoryPartyRejoinedEventServiceServer
// for forward compatibility.
//
// Publishes a PartyRejoinedEvent to the Mpv2 Session History channel. (oneOf variant) (mpv2SessionHistory PartyRejoinedEvent)
type Mpv2SessionHistoryPartyRejoinedEventServiceServer interface {
	OnMessage(context.Context, *PartyRejoinedEvent) (*emptypb.Empty, error)
}

// UnimplementedMpv2SessionHistoryPartyRejoinedEventServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMpv2SessionHistoryPartyRejoinedEventServiceServer struct{}

func (UnimplementedMpv2SessionHistoryPartyRejoinedEventServiceServer) OnMessage(context.Context, *PartyRejoinedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyRejoinedEventServiceServer) testEmbeddedByValue() {}

// UnsafeMpv2SessionHistoryPartyRejoinedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyRejoinedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyRejoinedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyRejoinedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyRejoinedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyRejoinedEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedMpv2SessionHistoryPartyRejoinedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mpv2SessionHistoryPartyRejoinedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyRejoinedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyRejoinedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyRejoinedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyRejoinedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyRejoinedEventServiceServer).OnMessage(ctx, req.(*PartyRejoinedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyRejoinedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyRejoinedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyRejoinedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyRejoinedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyRejoinedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyRejoinedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}
