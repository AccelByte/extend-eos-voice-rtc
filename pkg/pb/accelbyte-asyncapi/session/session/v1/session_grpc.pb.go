// Copyright (c) 2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

// source: Session/AsyncAPI/session.yaml (0.1.0)

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.9
// source: accelbyte-asyncapi/session/session/v1/session.proto

package session

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	SessionEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.SessionEventService/OnMessage"
)

// SessionEventServiceClient is the client API for SessionEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionEventServiceClient interface {
	OnMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionEventServiceClient(cc grpc.ClientConnInterface) SessionEventServiceClient {
	return &sessionEventServiceClient{cc}
}

func (c *sessionEventServiceClient) OnMessage(ctx context.Context, in *Event, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionEventServiceServer is the server API for SessionEventService service.
// All implementations must embed UnimplementedSessionEventServiceServer
// for forward compatibility
type SessionEventServiceServer interface {
	OnMessage(context.Context, *Event) (*emptypb.Empty, error)
	mustEmbedUnimplementedSessionEventServiceServer()
}

// UnimplementedSessionEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSessionEventServiceServer struct {
}

func (UnimplementedSessionEventServiceServer) OnMessage(context.Context, *Event) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedSessionEventServiceServer) mustEmbedUnimplementedSessionEventServiceServer() {}

// UnsafeSessionEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionEventServiceServer will
// result in compilation errors.
type UnsafeSessionEventServiceServer interface {
	mustEmbedUnimplementedSessionEventServiceServer()
}

func RegisterSessionEventServiceServer(s grpc.ServiceRegistrar, srv SessionEventServiceServer) {
	s.RegisterService(&SessionEventService_ServiceDesc, srv)
}

func _SessionEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionEventServiceServer).OnMessage(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionEventService_ServiceDesc is the grpc.ServiceDesc for SessionEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.SessionEventService",
	HandlerType: (*SessionEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _SessionEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	SessionNotificationSessionNotificationService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.SessionNotificationSessionNotificationService/OnMessage"
)

// SessionNotificationSessionNotificationServiceClient is the client API for SessionNotificationSessionNotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionNotificationSessionNotificationServiceClient interface {
	OnMessage(ctx context.Context, in *SessionNotification, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionNotificationSessionNotificationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionNotificationSessionNotificationServiceClient(cc grpc.ClientConnInterface) SessionNotificationSessionNotificationServiceClient {
	return &sessionNotificationSessionNotificationServiceClient{cc}
}

func (c *sessionNotificationSessionNotificationServiceClient) OnMessage(ctx context.Context, in *SessionNotification, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionNotificationSessionNotificationService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionNotificationSessionNotificationServiceServer is the server API for SessionNotificationSessionNotificationService service.
// All implementations must embed UnimplementedSessionNotificationSessionNotificationServiceServer
// for forward compatibility
type SessionNotificationSessionNotificationServiceServer interface {
	OnMessage(context.Context, *SessionNotification) (*emptypb.Empty, error)
	mustEmbedUnimplementedSessionNotificationSessionNotificationServiceServer()
}

// UnimplementedSessionNotificationSessionNotificationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSessionNotificationSessionNotificationServiceServer struct {
}

func (UnimplementedSessionNotificationSessionNotificationServiceServer) OnMessage(context.Context, *SessionNotification) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedSessionNotificationSessionNotificationServiceServer) mustEmbedUnimplementedSessionNotificationSessionNotificationServiceServer() {
}

// UnsafeSessionNotificationSessionNotificationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionNotificationSessionNotificationServiceServer will
// result in compilation errors.
type UnsafeSessionNotificationSessionNotificationServiceServer interface {
	mustEmbedUnimplementedSessionNotificationSessionNotificationServiceServer()
}

func RegisterSessionNotificationSessionNotificationServiceServer(s grpc.ServiceRegistrar, srv SessionNotificationSessionNotificationServiceServer) {
	s.RegisterService(&SessionNotificationSessionNotificationService_ServiceDesc, srv)
}

func _SessionNotificationSessionNotificationService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionNotification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionNotificationSessionNotificationServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionNotificationSessionNotificationService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionNotificationSessionNotificationServiceServer).OnMessage(ctx, req.(*SessionNotification))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionNotificationSessionNotificationService_ServiceDesc is the grpc.ServiceDesc for SessionNotificationSessionNotificationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionNotificationSessionNotificationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.SessionNotificationSessionNotificationService",
	HandlerType: (*SessionNotificationSessionNotificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _SessionNotificationSessionNotificationService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	SessionEventOnSessionEndedService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.SessionEventOnSessionEndedService/OnMessage"
)

// SessionEventOnSessionEndedServiceClient is the client API for SessionEventOnSessionEndedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionEventOnSessionEndedServiceClient interface {
	OnMessage(ctx context.Context, in *OnSessionEnded, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionEventOnSessionEndedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionEventOnSessionEndedServiceClient(cc grpc.ClientConnInterface) SessionEventOnSessionEndedServiceClient {
	return &sessionEventOnSessionEndedServiceClient{cc}
}

func (c *sessionEventOnSessionEndedServiceClient) OnMessage(ctx context.Context, in *OnSessionEnded, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SessionEventOnSessionEndedService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionEventOnSessionEndedServiceServer is the server API for SessionEventOnSessionEndedService service.
// All implementations must embed UnimplementedSessionEventOnSessionEndedServiceServer
// for forward compatibility
type SessionEventOnSessionEndedServiceServer interface {
	OnMessage(context.Context, *OnSessionEnded) (*emptypb.Empty, error)
	mustEmbedUnimplementedSessionEventOnSessionEndedServiceServer()
}

// UnimplementedSessionEventOnSessionEndedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSessionEventOnSessionEndedServiceServer struct {
}

func (UnimplementedSessionEventOnSessionEndedServiceServer) OnMessage(context.Context, *OnSessionEnded) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedSessionEventOnSessionEndedServiceServer) mustEmbedUnimplementedSessionEventOnSessionEndedServiceServer() {
}

// UnsafeSessionEventOnSessionEndedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionEventOnSessionEndedServiceServer will
// result in compilation errors.
type UnsafeSessionEventOnSessionEndedServiceServer interface {
	mustEmbedUnimplementedSessionEventOnSessionEndedServiceServer()
}

func RegisterSessionEventOnSessionEndedServiceServer(s grpc.ServiceRegistrar, srv SessionEventOnSessionEndedServiceServer) {
	s.RegisterService(&SessionEventOnSessionEndedService_ServiceDesc, srv)
}

func _SessionEventOnSessionEndedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSessionEnded)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionEventOnSessionEndedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionEventOnSessionEndedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionEventOnSessionEndedServiceServer).OnMessage(ctx, req.(*OnSessionEnded))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionEventOnSessionEndedService_ServiceDesc is the grpc.ServiceDesc for SessionEventOnSessionEndedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionEventOnSessionEndedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.SessionEventOnSessionEndedService",
	HandlerType: (*SessionEventOnSessionEndedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _SessionEventOnSessionEndedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionEndedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionEndedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionEndedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionEndedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionEndedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionEndedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionEndedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionEndedEventServiceClient {
	return &mpv2SessionHistoryGameSessionEndedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionEndedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionEndedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionEndedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionEndedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionEndedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionEndedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer) OnMessage(context.Context, *GameSessionEndedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionEndedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionEndedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionEndedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionEndedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionEndedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionEndedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionEndedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionEndedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionEndedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionEndedEventServiceServer).OnMessage(ctx, req.(*GameSessionEndedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionEndedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionEndedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionEndedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionEndedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionEndedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionEndedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionInvitedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionInvitedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionInvitedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionInvitedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionInvitedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionInvitedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionInvitedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionInvitedEventServiceClient {
	return &mpv2SessionHistoryGameSessionInvitedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionInvitedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionInvitedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionInvitedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionInvitedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionInvitedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionInvitedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer) OnMessage(context.Context, *GameSessionInvitedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionInvitedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionInvitedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionInvitedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionInvitedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionInvitedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionInvitedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionInvitedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionInvitedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionInvitedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionInvitedEventServiceServer).OnMessage(ctx, req.(*GameSessionInvitedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionInvitedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionInvitedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionInvitedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionInvitedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionInvitedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionInvitedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionJoinedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionJoinedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionJoinedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionJoinedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionJoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionJoinedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionJoinedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionJoinedEventServiceClient {
	return &mpv2SessionHistoryGameSessionJoinedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionJoinedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionJoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionJoinedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionJoinedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionJoinedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionJoinedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer) OnMessage(context.Context, *GameSessionJoinedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionJoinedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionJoinedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionJoinedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionJoinedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionJoinedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionJoinedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionJoinedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionJoinedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionJoinedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionJoinedEventServiceServer).OnMessage(ctx, req.(*GameSessionJoinedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionJoinedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionJoinedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionJoinedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionJoinedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionJoinedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionJoinedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionMembersChangedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionMembersChangedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionMembersChangedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionMembersChangedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionMembersChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionMembersChangedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionMembersChangedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionMembersChangedEventServiceClient {
	return &mpv2SessionHistoryGameSessionMembersChangedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionMembersChangedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionMembersChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionMembersChangedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionMembersChangedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer) OnMessage(context.Context, *GameSessionMembersChangedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionMembersChangedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionMembersChangedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionMembersChangedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionMembersChangedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionMembersChangedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionMembersChangedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer).OnMessage(ctx, req.(*GameSessionMembersChangedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionMembersChangedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionMembersChangedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionMembersChangedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionMembersChangedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionMembersChangedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionMembersChangedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionKickedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionKickedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionKickedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionKickedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionKickedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionKickedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionKickedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionKickedEventServiceClient {
	return &mpv2SessionHistoryGameSessionKickedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionKickedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionKickedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionKickedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionKickedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionKickedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionKickedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer) OnMessage(context.Context, *GameSessionKickedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionKickedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionKickedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionKickedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionKickedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionKickedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionKickedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionKickedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionKickedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionKickedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionKickedEventServiceServer).OnMessage(ctx, req.(*GameSessionKickedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionKickedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionKickedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionKickedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionKickedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionKickedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionKickedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCreatedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionCreatedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionCreatedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionCreatedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionCreatedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionCreatedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionCreatedEventServiceClient {
	return &mpv2SessionHistoryGameSessionCreatedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionCreatedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionCreatedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionCreatedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionCreatedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionCreatedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer) OnMessage(context.Context, *GameSessionCreatedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionCreatedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionCreatedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionCreatedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionCreatedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionCreatedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionCreatedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionCreatedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionCreatedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionCreatedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionCreatedEventServiceServer).OnMessage(ctx, req.(*GameSessionCreatedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionCreatedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionCreatedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionCreatedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCreatedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionCreatedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionCreatedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionUpdatedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionUpdatedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionUpdatedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionUpdatedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionUpdatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionUpdatedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionUpdatedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionUpdatedEventServiceClient {
	return &mpv2SessionHistoryGameSessionUpdatedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionUpdatedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionUpdatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionUpdatedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionUpdatedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionUpdatedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionUpdatedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer) OnMessage(context.Context, *GameSessionUpdatedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionUpdatedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionUpdatedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionUpdatedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionUpdatedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionUpdatedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionUpdatedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionUpdatedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionUpdatedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionUpdatedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionUpdatedEventServiceServer).OnMessage(ctx, req.(*GameSessionUpdatedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionUpdatedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionUpdatedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionUpdatedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionUpdatedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionUpdatedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionUpdatedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionRejectedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionRejectedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionRejectedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionRejectedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionRejectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionRejectedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionRejectedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionRejectedEventServiceClient {
	return &mpv2SessionHistoryGameSessionRejectedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionRejectedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionRejectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionRejectedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionRejectedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionRejectedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionRejectedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer) OnMessage(context.Context, *GameSessionRejectedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionRejectedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionRejectedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionRejectedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionRejectedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionRejectedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionRejectedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionRejectedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionRejectedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionRejectedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionRejectedEventServiceServer).OnMessage(ctx, req.(*GameSessionRejectedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionRejectedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionRejectedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionRejectedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionRejectedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionRejectedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionRejectedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionDSStatusChangedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionDSStatusChangedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionDSStatusChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient {
	return &mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionDSStatusChangedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionDSStatusChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionDSStatusChangedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionDSStatusChangedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer) OnMessage(context.Context, *GameSessionDSStatusChangedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionDSStatusChangedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionDSStatusChangedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer).OnMessage(ctx, req.(*GameSessionDSStatusChangedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionDSStatusChangedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionDSStatusChangedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionDSStatusChangedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionDSStatusChangedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionDSStatusChangedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionDSStatusChangedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCodeChangedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionCodeChangedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionCodeChangedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionCodeChangedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionCodeChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionCodeChangedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionCodeChangedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionCodeChangedEventServiceClient {
	return &mpv2SessionHistoryGameSessionCodeChangedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionCodeChangedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionCodeChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionCodeChangedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionCodeChangedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer) OnMessage(context.Context, *GameSessionCodeChangedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionCodeChangedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionCodeChangedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionCodeChangedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionCodeChangedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionCodeChangedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionCodeChangedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer).OnMessage(ctx, req.(*GameSessionCodeChangedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionCodeChangedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionCodeChangedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionCodeChangedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCodeChangedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionCodeChangedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionCodeChangedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCodeRevokedEventService/OnMessage"
)

// Mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient is the client API for Mpv2SessionHistoryGameSessionCodeRevokedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient interface {
	OnMessage(ctx context.Context, in *GameSessionCodeRevokedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryGameSessionCodeRevokedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient {
	return &mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryGameSessionCodeRevokedEventServiceClient) OnMessage(ctx context.Context, in *GameSessionCodeRevokedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer is the server API for Mpv2SessionHistoryGameSessionCodeRevokedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer interface {
	OnMessage(context.Context, *GameSessionCodeRevokedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer) OnMessage(context.Context, *GameSessionCodeRevokedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer()
}

func RegisterMpv2SessionHistoryGameSessionCodeRevokedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryGameSessionCodeRevokedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameSessionCodeRevokedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer).OnMessage(ctx, req.(*GameSessionCodeRevokedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryGameSessionCodeRevokedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryGameSessionCodeRevokedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryGameSessionCodeRevokedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryGameSessionCodeRevokedEventService",
	HandlerType: (*Mpv2SessionHistoryGameSessionCodeRevokedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryGameSessionCodeRevokedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyCreatedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyCreatedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyCreatedEventServiceClient is the client API for Mpv2SessionHistoryPartyCreatedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryPartyCreatedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyCreatedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyCreatedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyCreatedEventServiceClient {
	return &mpv2SessionHistoryPartyCreatedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyCreatedEventServiceClient) OnMessage(ctx context.Context, in *PartyCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyCreatedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyCreatedEventServiceServer is the server API for Mpv2SessionHistoryPartyCreatedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryPartyCreatedEventServiceServer interface {
	OnMessage(context.Context, *PartyCreatedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer) OnMessage(context.Context, *PartyCreatedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryPartyCreatedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyCreatedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyCreatedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyCreatedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyCreatedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyCreatedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryPartyCreatedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyCreatedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyCreatedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyCreatedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyCreatedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyCreatedEventServiceServer).OnMessage(ctx, req.(*PartyCreatedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyCreatedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyCreatedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyCreatedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyCreatedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyCreatedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyCreatedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyUpdatedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyUpdatedEventServiceClient is the client API for Mpv2SessionHistoryPartyUpdatedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryPartyUpdatedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyUpdatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyUpdatedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyUpdatedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyUpdatedEventServiceClient {
	return &mpv2SessionHistoryPartyUpdatedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyUpdatedEventServiceClient) OnMessage(ctx context.Context, in *PartyUpdatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyUpdatedEventServiceServer is the server API for Mpv2SessionHistoryPartyUpdatedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryPartyUpdatedEventServiceServer interface {
	OnMessage(context.Context, *PartyUpdatedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer) OnMessage(context.Context, *PartyUpdatedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryPartyUpdatedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyUpdatedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyUpdatedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyUpdatedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyUpdatedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyUpdatedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryPartyUpdatedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyUpdatedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyUpdatedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyUpdatedEventServiceServer).OnMessage(ctx, req.(*PartyUpdatedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyUpdatedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyUpdatedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyUpdatedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyUpdatedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyUpdatedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyUpdatedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyKickedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyKickedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyKickedEventServiceClient is the client API for Mpv2SessionHistoryPartyKickedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryPartyKickedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyKickedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyKickedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyKickedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyKickedEventServiceClient {
	return &mpv2SessionHistoryPartyKickedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyKickedEventServiceClient) OnMessage(ctx context.Context, in *PartyKickedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyKickedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyKickedEventServiceServer is the server API for Mpv2SessionHistoryPartyKickedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryPartyKickedEventServiceServer interface {
	OnMessage(context.Context, *PartyKickedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryPartyKickedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer) OnMessage(context.Context, *PartyKickedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyKickedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryPartyKickedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryPartyKickedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyKickedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyKickedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyKickedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyKickedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyKickedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryPartyKickedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyKickedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyKickedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyKickedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyKickedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyKickedEventServiceServer).OnMessage(ctx, req.(*PartyKickedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyKickedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyKickedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyKickedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyKickedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyKickedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyKickedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyLeaveEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyLeaveEventService/OnMessage"
)

// Mpv2SessionHistoryPartyLeaveEventServiceClient is the client API for Mpv2SessionHistoryPartyLeaveEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryPartyLeaveEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyLeaveEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyLeaveEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyLeaveEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyLeaveEventServiceClient {
	return &mpv2SessionHistoryPartyLeaveEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyLeaveEventServiceClient) OnMessage(ctx context.Context, in *PartyLeaveEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyLeaveEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyLeaveEventServiceServer is the server API for Mpv2SessionHistoryPartyLeaveEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryPartyLeaveEventServiceServer interface {
	OnMessage(context.Context, *PartyLeaveEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer()
}

// UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer) OnMessage(context.Context, *PartyLeaveEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer() {
}

// UnsafeMpv2SessionHistoryPartyLeaveEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyLeaveEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyLeaveEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyLeaveEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyLeaveEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyLeaveEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryPartyLeaveEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyLeaveEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyLeaveEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyLeaveEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyLeaveEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyLeaveEventServiceServer).OnMessage(ctx, req.(*PartyLeaveEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyLeaveEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyLeaveEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyLeaveEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyLeaveEventService",
	HandlerType: (*Mpv2SessionHistoryPartyLeaveEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyLeaveEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyInvitedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyInvitedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyInvitedEventServiceClient is the client API for Mpv2SessionHistoryPartyInvitedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryPartyInvitedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyInvitedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyInvitedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyInvitedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyInvitedEventServiceClient {
	return &mpv2SessionHistoryPartyInvitedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyInvitedEventServiceClient) OnMessage(ctx context.Context, in *PartyInvitedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyInvitedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyInvitedEventServiceServer is the server API for Mpv2SessionHistoryPartyInvitedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryPartyInvitedEventServiceServer interface {
	OnMessage(context.Context, *PartyInvitedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer) OnMessage(context.Context, *PartyInvitedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryPartyInvitedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyInvitedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyInvitedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyInvitedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyInvitedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyInvitedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryPartyInvitedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyInvitedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyInvitedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyInvitedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyInvitedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyInvitedEventServiceServer).OnMessage(ctx, req.(*PartyInvitedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyInvitedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyInvitedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyInvitedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyInvitedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyInvitedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyInvitedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyRejectedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyRejectedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyRejectedEventServiceClient is the client API for Mpv2SessionHistoryPartyRejectedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryPartyRejectedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyRejectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyRejectedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyRejectedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyRejectedEventServiceClient {
	return &mpv2SessionHistoryPartyRejectedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyRejectedEventServiceClient) OnMessage(ctx context.Context, in *PartyRejectedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyRejectedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyRejectedEventServiceServer is the server API for Mpv2SessionHistoryPartyRejectedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryPartyRejectedEventServiceServer interface {
	OnMessage(context.Context, *PartyRejectedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer) OnMessage(context.Context, *PartyRejectedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryPartyRejectedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyRejectedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyRejectedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyRejectedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyRejectedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyRejectedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryPartyRejectedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyRejectedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyRejectedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyRejectedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyRejectedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyRejectedEventServiceServer).OnMessage(ctx, req.(*PartyRejectedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyRejectedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyRejectedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyRejectedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyRejectedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyRejectedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyRejectedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyJoinedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyJoinedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyJoinedEventServiceClient is the client API for Mpv2SessionHistoryPartyJoinedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryPartyJoinedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyJoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyJoinedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyJoinedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyJoinedEventServiceClient {
	return &mpv2SessionHistoryPartyJoinedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyJoinedEventServiceClient) OnMessage(ctx context.Context, in *PartyJoinedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyJoinedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyJoinedEventServiceServer is the server API for Mpv2SessionHistoryPartyJoinedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryPartyJoinedEventServiceServer interface {
	OnMessage(context.Context, *PartyJoinedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer) OnMessage(context.Context, *PartyJoinedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryPartyJoinedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyJoinedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyJoinedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyJoinedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyJoinedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyJoinedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryPartyJoinedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyJoinedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyJoinedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyJoinedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyJoinedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyJoinedEventServiceServer).OnMessage(ctx, req.(*PartyJoinedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyJoinedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyJoinedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyJoinedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyJoinedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyJoinedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyJoinedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryPartyMembersChangedEventService/OnMessage"
)

// Mpv2SessionHistoryPartyMembersChangedEventServiceClient is the client API for Mpv2SessionHistoryPartyMembersChangedEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryPartyMembersChangedEventServiceClient interface {
	OnMessage(ctx context.Context, in *PartyMembersChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryPartyMembersChangedEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryPartyMembersChangedEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryPartyMembersChangedEventServiceClient {
	return &mpv2SessionHistoryPartyMembersChangedEventServiceClient{cc}
}

func (c *mpv2SessionHistoryPartyMembersChangedEventServiceClient) OnMessage(ctx context.Context, in *PartyMembersChangedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryPartyMembersChangedEventServiceServer is the server API for Mpv2SessionHistoryPartyMembersChangedEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryPartyMembersChangedEventServiceServer interface {
	OnMessage(context.Context, *PartyMembersChangedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer()
}

// UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer) OnMessage(context.Context, *PartyMembersChangedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer() {
}

// UnsafeMpv2SessionHistoryPartyMembersChangedEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryPartyMembersChangedEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryPartyMembersChangedEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryPartyMembersChangedEventServiceServer()
}

func RegisterMpv2SessionHistoryPartyMembersChangedEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryPartyMembersChangedEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryPartyMembersChangedEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartyMembersChangedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryPartyMembersChangedEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryPartyMembersChangedEventServiceServer).OnMessage(ctx, req.(*PartyMembersChangedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryPartyMembersChangedEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryPartyMembersChangedEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryPartyMembersChangedEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryPartyMembersChangedEventService",
	HandlerType: (*Mpv2SessionHistoryPartyMembersChangedEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryPartyMembersChangedEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricTotalActiveSessionEventService/OnMessage"
)

// Mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient is the client API for Mpv2SessionHistoryMetricTotalActiveSessionEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricTotalActiveSessionEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricTotalActiveSessionEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient {
	return &mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricTotalActiveSessionEventServiceClient) OnMessage(ctx context.Context, in *MetricTotalActiveSessionEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer is the server API for Mpv2SessionHistoryMetricTotalActiveSessionEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer interface {
	OnMessage(context.Context, *MetricTotalActiveSessionEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer()
}

// UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer) OnMessage(context.Context, *MetricTotalActiveSessionEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer() {
}

// UnsafeMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricTotalActiveSessionEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryMetricTotalActiveSessionEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricTotalActiveSessionEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer).OnMessage(ctx, req.(*MetricTotalActiveSessionEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricTotalActiveSessionEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricTotalActiveSessionEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricTotalActiveSessionEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricTotalActiveSessionEventService",
	HandlerType: (*Mpv2SessionHistoryMetricTotalActiveSessionEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricTotalActiveSessionEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService/OnMessage"
)

// Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient is the client API for Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricAcquiringDsWaitTimeEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient {
	return &mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceClient) OnMessage(ctx context.Context, in *MetricAcquiringDsWaitTimeEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer is the server API for Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer interface {
	OnMessage(context.Context, *MetricAcquiringDsWaitTimeEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer()
}

// UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer) OnMessage(context.Context, *MetricAcquiringDsWaitTimeEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer() {
}

// UnsafeMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricAcquiringDsWaitTimeEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer).OnMessage(ctx, req.(*MetricAcquiringDsWaitTimeEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService",
	HandlerType: (*Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricAcquiringDsWaitTimeEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricAcquiringDsEventService/OnMessage"
)

// Mpv2SessionHistoryMetricAcquiringDsEventServiceClient is the client API for Mpv2SessionHistoryMetricAcquiringDsEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryMetricAcquiringDsEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricAcquiringDsEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricAcquiringDsEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricAcquiringDsEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricAcquiringDsEventServiceClient {
	return &mpv2SessionHistoryMetricAcquiringDsEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricAcquiringDsEventServiceClient) OnMessage(ctx context.Context, in *MetricAcquiringDsEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricAcquiringDsEventServiceServer is the server API for Mpv2SessionHistoryMetricAcquiringDsEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryMetricAcquiringDsEventServiceServer interface {
	OnMessage(context.Context, *MetricAcquiringDsEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer()
}

// UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer) OnMessage(context.Context, *MetricAcquiringDsEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer() {
}

// UnsafeMpv2SessionHistoryMetricAcquiringDsEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricAcquiringDsEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricAcquiringDsEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricAcquiringDsEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricAcquiringDsEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricAcquiringDsEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryMetricAcquiringDsEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricAcquiringDsEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricAcquiringDsEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricAcquiringDsEventServiceServer).OnMessage(ctx, req.(*MetricAcquiringDsEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricAcquiringDsEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricAcquiringDsEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricAcquiringDsEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricAcquiringDsEventService",
	HandlerType: (*Mpv2SessionHistoryMetricAcquiringDsEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricAcquiringDsEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}

const (
	Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_FullMethodName = "/accelbyte.session.session.v1.Mpv2SessionHistoryMetricMatchLengthDurationEventService/OnMessage"
)

// Mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient is the client API for Mpv2SessionHistoryMetricMatchLengthDurationEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient interface {
	OnMessage(ctx context.Context, in *MetricMatchLengthDurationEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMpv2SessionHistoryMetricMatchLengthDurationEventServiceClient(cc grpc.ClientConnInterface) Mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient {
	return &mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient{cc}
}

func (c *mpv2SessionHistoryMetricMatchLengthDurationEventServiceClient) OnMessage(ctx context.Context, in *MetricMatchLengthDurationEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer is the server API for Mpv2SessionHistoryMetricMatchLengthDurationEventService service.
// All implementations must embed UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer
// for forward compatibility
type Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer interface {
	OnMessage(context.Context, *MetricMatchLengthDurationEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer()
}

// UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer struct {
}

func (UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer) OnMessage(context.Context, *MetricMatchLengthDurationEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer) mustEmbedUnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer() {
}

// UnsafeMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer will
// result in compilation errors.
type UnsafeMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer interface {
	mustEmbedUnimplementedMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer()
}

func RegisterMpv2SessionHistoryMetricMatchLengthDurationEventServiceServer(s grpc.ServiceRegistrar, srv Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer) {
	s.RegisterService(&Mpv2SessionHistoryMetricMatchLengthDurationEventService_ServiceDesc, srv)
}

func _Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricMatchLengthDurationEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer).OnMessage(ctx, req.(*MetricMatchLengthDurationEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// Mpv2SessionHistoryMetricMatchLengthDurationEventService_ServiceDesc is the grpc.ServiceDesc for Mpv2SessionHistoryMetricMatchLengthDurationEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mpv2SessionHistoryMetricMatchLengthDurationEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.session.session.v1.Mpv2SessionHistoryMetricMatchLengthDurationEventService",
	HandlerType: (*Mpv2SessionHistoryMetricMatchLengthDurationEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _Mpv2SessionHistoryMetricMatchLengthDurationEventService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/session/session/v1/session.proto",
}
